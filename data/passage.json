{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1787761231348633601",
        "title": "离开大厂创业一年，从未受过这么大的打击！",
        "description": null,
        "content": "大家好，我是程序员鱼皮。时间过得真快呀，转眼间我从腾讯出来、自主创业竟然已经整整一年了！上周末也带团队同学们搞了场公司周年庆团建。\n\n我自己是一个很喜欢、也很注重复盘总结的人，这么重要的时间，当然要对过去的一整年做一个全面的复盘，也想让大家进一步了解我们公司这一年的发展过程。所以写下了这篇文章，并录制了一个视频。\n\n推荐大家看视频，感受一下我的创业血泪史：https://www.bilibili.com/video/BV1iD421p7gP\n\n\n\n---\n\n\n\n以下是我对一周年复盘的文字版。\n\n\n\n## 前言\n\n24 岁时，我做了一个决定，离开待了近 4 年的大厂，组了个 4 人小队，来到这间小办公室，在毫无经验的情况下，开启了一场艰难的创业之旅。\n\n![初创时的办公室](https://pic.yupi.icu/1/image-20240416145749498.png)\n\n\n\n## 现状介绍\n\n转眼一整年过去了，幸运的是，公司并没有倒闭。团队也从刚开始的 4 人，发展到目前的 15 人左右，公司的盈利也相对稳定。\n\n![公司周年庆合照](https://pic.yupi.icu/1/%E5%91%A8%E5%B9%B4%E5%BA%86%E5%8F%A3%E5%8F%B7%E5%90%88%E7%85%A7.jpg)\n\n如果不算头发、健康和精神的损失，发展确实还算乐观。\n\n老实说，创业这一年，我经历了之前 20 多年人生都从未有过的打击，甚至比高考的失利还要大。\n\n![](https://pic.yupi.icu/1/%E7%97%85%E5%8F%B72.jpg)\n\n那过去的一年，我到底经历了什么，能把一名年轻帅气的小伙折磨成殃殃病号？且听我娓娓道来这段创业血泪史。\n\n\n\n## 去年公司的经历\n\n### 23 年 4 - 5 月：热情高涨\n\n4 月刚开业，公司只有一位运营兼产品、一位销售兼运营、一名前端开发、加一名后端开发（就是本人），还有一名兼职的设计师。\n\n虽然就这几个人，但我当时热情高涨、信心满满，觉得凭着自己做项目的经验、再加上 AI 的爆发，有很多成功的机会，所以我带着仅有的一名前端同学就开干了。\n\n因为我很想做出一款真正属于自己的产品，所以并没有直接拿开源代码套壳，而是完完全全从 0 开始，用了一个月左右的时间，上线了 `《鱼聪明 AI》` 这样的 AI 助手平台。\n\n> 鱼聪明 AI：[https://yucongming.com](https://yucongming.com)\n\n![](https://pic.yupi.icu/1/image-20240416145955119.png)\n\n刚开始很顺利，上线一周左右用户数就突破了 5 万，我也开始幻想自己能够成为比尔盖茨了，当时对外给我的读者和学员免费送会员福利，对内还带着同事们一起去北京团建游玩。\n\n\n\n### 23 年 6 月：梦想破灭\n\n但是！变化来得太突然了。\n\n6 月初，我们的产品就 **破产** 了，入不敷出！\n\n这件事给了我沉重的打击，毕竟公司的第一个产品、做了这么久的产品、给予了这么大希望的产品，突然就破产了，搁谁头上谁发畜啊！\n\n都说要拥抱变化，我特么的拥抱不住啊！！！\n\n![](https://pic.yupi.icu/1/image-20240416150130298.png)\n\n冷静分析一下，破产的原因主要有 3 点：\n\n1. 首先是 AI 产品遭到了大规模的封杀，我们只能停止推广，产品新用户骤减。\n2. 越来越多的同类套壳 AI 产品加剧内卷，导致收入减少。对用户来说，大家并不在意这个东西是不是你自己做的，能解决他们的需求就行。即便我们从 0 开始写代码，很多人也会觉得跟套壳的没有区别，甚至有些体验还不如套壳的。\n3. 前期发展过于理想，导致我们白送了大量的会员，被薅了羊毛，没有控制好成本。\n\n![](https://pic.yupi.icu/1/%E9%B1%BC%E8%81%AA%E6%98%8E%E7%A0%B4%E4%BA%A7%E6%88%AA%E5%9B%BE.png)\n\n\n\n通过这件事，我也意识到，在没有稳定的、有竞争力的高质量团队的情况下，追求爆款的代价太大了，不如踏踏实实做点有长期价值的事实。所以我决定从自身和学员的需求出发，做一款求职写简历的工具产品 `《老鱼简历》`。\n\n> 老鱼简历：[https://laoyujianli.com](https://laoyujianli.com)\n\n![](https://pic.yupi.icu/1/image-20240416150225404.png)\n\n我也意识到了不能再用传统码农的思想，自己去写代码了，应该把工作下放。于是从我自己的编程导航学习圈中招募了一名很优秀的后端开发同学，跟我们的前端打配合，专注于老鱼简历的研发。\n\n![](https://pic.yupi.icu/1/image-20240416150259778.png)\n\n其实这个阶段，我何尝不想招更多人来加速产品的研发呢？\n\n但因为自己做事的风格是相对来说追求稳定的，感觉自己的管理经验还不够，所以不敢盲目扩张。\n\n\n\n### 23 年 7 - 8 月：公司稳定\n\n7 月到 8 月的时候，公司的发展非常稳定，但是我却对外发布了一篇文章，标题为 “公司太稳定了我好慌”。\n\n![](https://pic.yupi.icu/1/%E5%85%AC%E5%8F%B8%E5%A4%AA%E7%A8%B3%E5%AE%9A%E4%BA%86.png)\n\n为什么慌呢？\n\n因为公司是 **稳定地赚不着钱** 啊！\n\n相比之前我自己做自媒体和编程教育，开公司后，收入稳定地没有增涨，成本却大幅增加。场地、设备、员工薪资，都是成本。而且当时我给所有员工配备的都是高配的苹果电脑，毕竟虽然是创业，还是想给大家更好的工作体验。\n\n![光电脑就有十几台](https://pic.yupi.icu/1/image-20240416150420996.png)\n\n为此，我必须要带领团队扩张新的业务！\n\n欣慰的是，经过 2 个月左右的磨合，团队同学们和我都适应了工作节奏，我可以从写代码的工作中抽身，让我有了更多的空余时间。\n\n这两个月，我主要做了 3 类事情：\n\n1）继续自媒体内容分享，想为公司带来更大的流量，比如当时我花了几周的时间写自己的专栏。但现在回过头来看，我很后悔做这件事，因为我们没有盈利业务的情况下，现阶段做这件事对团队的收益很低，写作更多的是满足了个人的兴趣，所以我把它认为是一种摸鱼。\n\n![](https://pic.yupi.icu/1/%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%93%E6%A0%8F.png)\n\n2）我尝试开设高客单价的产品 “1 对 1 编程私教服务”，其实也不是什么新鲜的东西了，但我敢做这件事是因为自己在社群里已经带很多同学上岸了，经验还是比较丰富的。\n\n有了上次的失败经验，这次我选择 “灰度”，只通过精挑细选找了几个学员，然后自己亲自带。结果你猜怎么着，做了短短几天，我就放弃了。\n\n为啥呢？\n\n虽然学员都很满意，但实在太累了！这种完全 1 对 1 的模式，注定是无法持久的。\n\n![](https://pic.yupi.icu/1/1712802106571-9debad8f-1bc4-47ba-8b4d-ffc33ffc68c0-20240416145221468.png)\n\n\n\n不过虽然这事没做成，我还是得到了不少经验，尤其是意识到了合作的重要性。当我们人力有限的情况下，想要增加营收，就需要借助外力互利共赢。\n\n于是这段时间我在线上、线下疯狂找人交流合作，最后联合其他信任的博主一起开设了编程后端训练营、前端训练营、以及考研辅导社群，也成功为我们增加了盈利点。\n\n\n\n3）不忘初心，继续带团队开发产品。\n\n除了帮大家轻松写出专业简历的老鱼简历外，我们当时还做了帮创作者提升效率的工具 `《知识助手》` 以及知识百科类网站 `《蛋蛋百科》`。\n\n![](https://pic.yupi.icu/1/image-20240416150517511.png)\n\n大家可能想象不到，这几个产品在当时竟然是由我们仅有的 2 名开发同学做的（虽然略显粗糙）。\n\n为什么在这个时候我们要搞这么多产品呢？\n\n**主要是为了布局。**\n\n在我意识到做爆款的难度后，我决定追求长期发展，先提前占坑。而且我自己技术出身、项目经验丰富，所以非常注重开发效率和技术沉淀。我带着开发同学打造了快速开发项目的模板，同时保证功能只需要开发一次，其他项目就能直接用。所以开发新项目的成本并不高，还能在这个过程中持续提升团队的能力、沉淀更多技术能力。等未来我们主营业务稳定后，再扩招专业的产品、运营和更多开发，来激活和发展这些项目即可。\n\n\n\n------\n\n\n\n那同时做这么多事，再加上我一直在直播带学员做项目、答疑，再加上每月巨额的开销。这几个月我差不多要得焦虑症了，而且身体每况愈下，比如直播一场后会持续咳嗽好几天。\n\n给大家欣赏下我当时的日记，应该能从字里行间中感受到我那时的无奈，用一个词形容就是 **“麻了”** 。\n\n![](https://pic.yupi.icu/1/1712802140951-8979bc48-98c6-4629-bc70-2f46b080f078-20240416145221806.png)\n\n![](https://pic.yupi.icu/1/1712802174708-80636319-c02b-4900-995e-64a25a80d22e-20240416145222154.png)\n\n![](https://pic.yupi.icu/1/1712802209588-6bf22f22-8b5b-4e3f-8b0e-ee1b0a7becc1-20240416145222423.png)\n\n![](https://pic.yupi.icu/1/1712802764710-7dbba57d-e2c2-42d3-a2d7-964ff3fe7379-20240416145223381.png)\n\n\n\n当时我真的是又累、又迷茫，还经常跟团队同学吐槽：写代码真的是最简单的事情，起码机器是不会欺骗你的。\n\n\n\n### 23 年 9 - 10 月：深陷迷茫\n\n去年 9 月和 10 月，是我最忙碌、也是最迷茫的时期。\n\n因为当时已经做了很多产品，却没有实质性的收益和里程碑，就会怀疑自己，陷入更深的迷茫。\n\n前辈说，当你觉得越忙、事情越做不完，越需要静下心来审视自己的工作和规划，学会解放自己，否则只会越陷越深。\n\n于是我问自己：我现在做的种种工作，真的需要自己来么？\n\n比如做项目，我的职责应该是整体的项目设计、推进和指导，保证团队能顺利完成就好，而不是去改 Bug、做调研、写文档，什么事都亲力亲为。更多的应该是去做公司决策、争取资源、真人出镜直播，这种只有我能做的事情。\n\n于是，这两个月，除了迭代更新我们原有的产品外，我重点做了以下 2 件事：\n\n1）团队内部建设。包括完善和优化公司内部的知识库和文档，整理可以通过招人进行下放的工作，针对这些工作沉淀工作流文档，目标是让其他人看了这个文档也能快速上手完成工作。\n\n![](https://pic.yupi.icu/1/%E5%AE%8C%E5%96%84%E7%9F%A5%E8%AF%86%E5%BA%93%E5%92%8C%E6%96%87%E6%A1%A3.png)\n\n2）招人。**必须要招人，解放自己！**\n\n但招人谈何容易呢？\n\n我们在各大平台都发起了招聘，大家也都很热情投递。但我们并没有专业的 HR，都是我和另一名同学看简历、约面、面试，而且很多简历都是无效简历，效率不高，消耗了大量的时间。\n\n最让我受到打击的是，有一些我很看好的同学，面试结束后就去别家了，感觉像是被求职者刷了 KPI 一样。唉，谁让我们只是个创业小公司呢？\n\n记得那是一个月黑风高的夜晚，我仰天长啸：想找到合适的人太难了！知音难觅！知音难觅啊！\n\n也是这段时间，由于长期熬夜、直播耗气、饮食不规律、精神压力大，导致我的肠胃经常疼痛，经常往医院跑，甚至专门住院做了检查，也打乱了工作节奏。\n\n![](https://pic.yupi.icu/1/%E7%97%85%E5%8F%B73.jpg)\n\n住院后，我就知道珍惜身体了，后来养了一段时间稍微好点了，但最近我还要去复诊。所以也提醒各位朋友，**身体健康是最重要的**，一定要吃早饭、一定要规律饮食、一定要少熬夜、压力大的时候 **学会舍得**。\n\n后来，关于招人难这点我也请教了一些前辈，其中有个思路我觉得非常好：创业公司不能只靠待遇来招人，而是要突出自己的产品优势，吸引志同道合的人。\n\n于是我们也根据这点优化了招聘文案，并且为了更好地向大家展示我们公司，我利用建站工具快速搭建了公司官网，传递了我们的理念 “用科技节约您的每一分钟”。\n\n> 我们的官网：[https://yuyuanweb.com](https://yuyuanweb.com)\n\n![](https://pic.yupi.icu/1/1712913774918-94e0d00f-79b1-4372-88c0-5707eb2363d2-20240416145224037.png)\n\n\n\n### 23 年 11 月：新的希望\n\n和高人聊真的是能解决问题的，终于在 11 月初，我们招到了合适的新人，包括开发、销售、产品和运营，团队总人数一下子升到了 10 人左右。\n\n原来的小办公室都坐不下了，所以我扩张了公司的地盘，拿下了一个更大的办公场地。\n\n![新办公场地](https://pic.yupi.icu/1/image-20240416150755801.png)\n\n看着新面孔和新的办公环境，我瞬间感觉轻松了不少，充满了希望！\n\n有了之前积累的管理经验和沉淀下来的工作流，这次新人上手工作都比较快，我们也顺水推舟地启动了几个新的业务。比如简单易用的多设备代码分享神器 `《代码小抄》`，分享每日优质科技信息的自媒体 `《科技信息差》`，还有颜值天花板的剪切板增强工具 `《剪切助手》`，这些工具的制作初衷都是为了帮大家提高效率、节约时间，符合我们公司的理念。\n\n> 代码小抄：https://codecopy.cn\n\n![](https://pic.yupi.icu/1/image-20240416150824013.png)\n\n当然，团队扩招也意味着公司的管理模式要进行相应的改变。\n\n比如开发同学增多，我们就更注重内部的技术沉淀、开发规范和文档建设。\n\n还有工作模式的改变：以前人少的时候，我们所有同学公用一个工作记录表格；但现在人多了，集中的记录表就不适用了，我们选择了大多数公司都在用的 “周报 + 周会” 模式，便于定期了解和复盘团队成员的工作。\n\n\n\n### 24 年 3 月：工作模式变革\n\n后来很长一段时间，公司处于稳定发展的状态，大家各司其职，没出过什么大问题。\n\n但唯独有一点没有变化，那就是 “我还是很累”。因为所有同学的工作都需要我来规划和分配、有事都要向我反馈、工作都需要找我确认、出事了都需要我来扛着，我每天要花大量时间处理碎片化的工作消息，很难抽身专注去做一件事。\n\n为了解决这个问题，我曾经让团队一名同学承担项目管理的工作，尝试帮我分担压力。但后来他也发现，由于公司产品和业务太多、每个人的工作不同，即使经常主动询问、也存在信息差，不好管理所有人的工作进度。\n\n这种问题一直困扰着我，直到 2 月底，机缘巧合下，一位有经验的产品大佬加入了我们团队。他发现我们团队同学缺少创业的激情，而且工作效率不高，一个很大的原因就是很多工作都是由我规划、由我分配的，如果我有一天不在，可能就会影响团队的部分工作推进。\n\n于是，他提出了 **负责人模式**，每个产品都有一个负责人。区别于之前我来分配工作、大家机械地完成，现在我只需要定好计划，剩下的就是由负责人整理需求、主动发起会议确认工作、自主安排工作、上线后主动汇报。当然在这个过程中我们会一起交流讨论，并提供一些指导建议。\n\n试行负责人模式一个月后，我发现大家的自主性更强了，成长也更快了，尤其是开发同学，不再是只会写代码的 “码农”，在产品、运营、数据等多个方面都有了自己的思考，相信很快就可以独当一面了。\n\n与之相应的，我也变得更轻松了，开始有时间去挖掘合作机会、进一步提升流量和影响力。\n\n\n\n### 24 年 4 月：新的希望\n\n时间回到现在，经过一年的积累，我有了更多的管理经验和更清晰的规划，再加上各个产品的增长相对稳定、团队积极性的提升，让我的压力也小了很多，感觉看到了更大的希望。\n\n所以就在前不久，我开启了进一步的扩招，包括开发、运营、用户增长、技术负责人等岗位，完善团队的能力。\n\n有了之前招聘的经验，这次的招聘质量和效率都高了很多，我也让团队的同学担任了一面的面试官，帮我减轻了不少压力，我也不再认为招聘是痛苦的了。\n\n很快，我们就招到了几位新同学，也就有了现在的团队。\n\n![](https://pic.yupi.icu/1/%E5%9B%A2%E5%BB%BA%E5%90%88%E7%85%A72.jpg)\n\n现在的我，已经不再迷茫，对未来也充满了信心！\n\n\n\n## 总结 - 我的感受和改变\n\n这就是我的创业故事，很多个人经验已经在经历中讲过了，再做个简单的总结吧，概括下这一年来我的感受和改变。\n\n1）创业前，我天真地以为，开公司之后可以有更多自由的时间，我能更专注于做好一件事。\n\n刚创业时，我还保留着独立开发者的思维，自己写代码、什么都亲力亲为、很多事情自己扛，结果换来的就是低效、焦虑、迷茫的恶性循环。当时我的感受是：好怀念以前只用专心写代码搬砖，出了事上级兜着的时光啊！\n\n创业的这一年，我做过 HR、销售、客服、讲师、前后端开发、产品、运营、市场、公关、管理、数据分析、清洁工、行政等各种工作，自己有一定经验后，也学会了下放工作来解放自己，然后可以尝试更多新的工作。相比于之前只写代码，我会更享受现在这样多元的工作状态，充满了新鲜感和可能性。\n\n我变强了！我变强了！我变强了！（也变秃了）\n\n\n\n2）刚创业时，我很害怕踩坑、害怕失败。但是经历了越来越多的失败后，我发现自己不仅没有 “麻痹”，反而 “上瘾了”！因为每次失败，都会有相应的成长：\n\n- 产品破产，让我有了更多对产品和商业的思考\n- 招人不慎，会让我更谨慎地调整招聘标准\n- 出了线上 Bug，会让我们更注重研发流程和规范\n- 合同被违约，会帮我们提升法律意识、更注重合同的细节\n\n\n\n现在的我，越来越享受踩坑的过程，心态也更稳定了。\n\n我不会像以前一样畏手畏脚，而是有了清晰的想法后就立刻去做、大胆去做，因为路是自己走出来的，经验是只有踩坑才会积累来的，前期的踩坑和失败，是为了以后的顺利和成功。\n\n还有很多我创业后才明白的道理，给大家分享几条。\n\n\n\n### 创业后才明白的道理\n\n1. 在你没有办法说服自己前，不要想着去说服别人\n2. 永远不要向任何人透露自己的底牌，凡事留一手\n3. 没有真正信得过的人，只有站的住的利益\n4. 无论发生什么，都不要觉得意外，都要以平常心对待\n5. 学会利他，合作前先换位思考，明确对方的诉求\n6. 不要把产品想的太复杂，遵循最小可用性原则，先快速验证、持续迭代\n7. 注重公司的内部沉淀，尤其是工作流和规范文档\n8. 记录下自己的创业过程，这是独特的经验，也是宝贵的财富\n9. 身体是革命的本钱，要做好长线发展的准备，不要盲目焦虑\n10. 时刻保持警惕，假定最坏的结果会发生并提前做好兜底策略\n\n\n\n## 未来计划\n\n去年，我更多地是在踩坑、积累、尝试、布局。\n\n今年，我已经准备好了，争取做到以下 4 点：\n\n1. 打磨一款稳定盈利的、用户认可的好产品。\n2. 持续完善工具类产品，帮助到几十万用户。\n3. 提升编程导航的影响力，打出自己的品牌。\n4. 拥有一个稳定高效、相互信任、充满激情的团队。\n\n有些计划其实我之前也分享过，还想尝试更多新鲜的事物哈哈！\n\n![](https://pic.yupi.icu/1/1712805253353-ff802594-6fb5-444f-be32-8fd8f96e6fcd-20240416145225930.png)\n\n\n\n我相信关注我们的朋友，能注意到我们现有产品的高速迭代，而且再过不久，我们就会再正式发布一个新的产品哦~\n\n猜到是什么的朋友可以在评论区打出答案哈哈。\n\n\n\n## 结尾\n\n最后，我想说，虽然创业是艰难的，我也曾受到很多打击，但这是我自己的选择，我一定会坚持到底。\n\n感谢看好我们的人，更感谢不看好我们的人，因为现在这个阶段，我反而更期待质疑的声音，这会让我持续保持警惕、才会有更多改进的机会。而且我觉得比起打顺风局，逆风翻盘才最有意思，不是么？\n\n但无论大家怎么看待我，我在做自己认为正确的、有意义的、让我快乐的事情，我们在为更多用户带来价值，这就够了。\n\n![](https://pic.yupi.icu/1/image-20240416151410139.png)\n\n感谢您的阅读和观看，也欢迎为我们点赞支持，谢谢大家！",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/U9gkOcus-离开大厂创业一年，从未受过这么大的打击！.jpeg",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 30,
        "thumbNum": 6,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-05-07 16:27:47",
        "updateTime": "2024-05-08 12:01:03",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3095,
          "coin": 170,
          "followeeNum": 1510,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2287-05-20 01:46:39",
          "lastLoginTime": null,
          "createTime": "2022-12-09 12:32:33",
          "updateTime": "2024-05-08 10:43:13"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1787756601068089345",
        "title": "3年-前端工程师",
        "description": "",
        "content": "目前个人情况\n\n当前在福建福州，从年前1月被裁员，最近才开始准备找工作\n\n在上一家公司在当地有一定名气，可能其他一二线城市不太知道。但我所在的是一个纯外包的部门（给兴业银行做人力外包），因此可能还是想在当地找。\n\n在上家做了两个项目（都在简历上了），目前比较头疼的也是这段经历，项目内容实在可写的不多。\n\n技术方面都是写的Vue，React最近学了一点，最开始是写Java的 在第二份工作时转的前端。\n\n以下是最近更新的简历：\n\n[简历](https://laoyujianli.com/share/G1whtu)\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 14,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1712659779119345666",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-05-07 16:09:23",
        "updateTime": "2024-05-08 12:04:32",
        "user": {
          "id": "1712659779119345666",
          "planetCode": "30424",
          "userName": "LeoJ",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1712659779119345666/A5rA45Mq-20201220_020240930_iOS.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/LeoJ340",
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-12-15 23:53:41",
          "lastLoginTime": null,
          "createTime": "2023-10-13 10:41:25",
          "updateTime": "2024-03-22 00:02:58"
        },
        "tags": [
          "文章",
          "简历"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1787442311098396673",
        "title": "升级了项目的部署方式，坑死我了！",
        "description": null,
        "content": "大家好，我是程序员鱼皮。如标题所言，最近这两天，我对我们公司部分项目的部署方式进行了改造升级。\n\n由于部署方式的调整可能会影响到线上用户的正常访问，所以只能挑在用户少的时间（凌晨）进行调整和测试。\n\n结果没想到踩了不少坑，直到昨天半夜我还在跟其他团队的技术同学一起找 Bug：\n\n![](https://pic.yupi.icu/1/WX20240429-124229@2x.png)\n\n这篇文章给大家分享下我们项目部署方式升级的形式、过程以及遇到的一些坑点，说不定以后大家也会用到~\n\n\n\n## 为什么要进行升级？\n\n最开始的时候，我们的项目几乎都是部署到服务器上的，而且很多项目是共用一台服务器，像这样：\n\n![](https://pic.yupi.icu/1/image-20240429125800155.png)\n\n为啥要这么做呢？\n\n答案很简单，成本低啊！因为我正好有几台配置很高的服务器，这些服务器如果只部署 1 - 2 个项目，CPU、内存、带宽都用不满，妥妥的浪费资源。\n\n而且现在小公司或个人部署项目可以直接使用宝塔 Linux 面板，非常方便。\n\n所以除非必要，我们尽量不会使用额外产生费用的 CDN、按量计费的容器平台等等。\n\n转眼从我创业到现在已经过去了一年多，为什么我们现在要重新调整项目的部署方式呢？\n\n主要的几个原因：\n\n1）随着业务增长，单体项目未必能够满足诉求，我们可能要将同一个项目部署在多个节点上，实现负载均衡和容错，手动部署就太麻烦了。这就需要能够灵活扩缩容机器节点的能力和流水线部署的能力。\n\n2）项目部署在同一服务器，如果服务器宕机，将同时影响多个项目。\n\n3）项目之间存在资源竞争，比如某个项目正在做大力推广、占用大量带宽资源，其他项目的可用带宽就很少了，访问会很慢。\n\n4）权限风险。一旦给开发者开通服务器的访问权限，将能改动所有项目，还有误操作的可能性。\n\n基于这些原因，再加上出现过一些事故，我们决定升级项目的部署方式。\n\n\n\n## 部署方式变更\n\n以前，我们的部署方式如下图：\n\n![](https://pic.yupi.icu/1/image-20240429131528251.png)\n\n用户要请求网站时，先通过 DNS 域名解析，找到服务器对应的 IP，经过高防服务器后请求发送到 Nginx Web 服务器。然后 Nginx 根据请求路径判断，如果要访问文件，找到前端网站文件；如果请求的是接口，反向代理到后端服务。\n\n升级后，我们的部署方式如下图：\n\n![](https://pic.yupi.icu/1/image-20240429131856035.png)\n\n主要有 3 个改动：\n\n1）接入有安全防护和资源加速能力的 CDN，可以提高前端网站的加载速度。\n\n2）后端使用容器平台进行部署，拥有动态扩缩容、负载均衡的能力。\n\n3）前后端部署分离，不再依赖 Nginx 进行转发，而是区分不同的请求域名，通过 DNS 解析到不同的 CDN 上。\n\n\n\nCDN 平台我是同时使用了腾讯云 CDN 和蓝易云 CDN，不同的项目选择了不同的 CDN。蓝易云 CDN（tsycdn.com）虽然不像腾讯云那么有名，但是性价比更高，能够有效防止 DDOS 攻击。在我网站被频繁攻击的那段时间，他们也帮了我不少。\n\n![](https://pic.yupi.icu/1/image-20240429132601809.png)\n\n而且最打动我的还是他们的技术支持，能耐心陪我一起改几个小时的 Bug，没谁了：\n\n![](https://pic.yupi.icu/1/image-20240429132435086.png)\n\n容器平台的话，我们将一部分服务放在了微信云托管上，可以很方便地配置流水线，实现提交代码到 GitHub 后自动发布和部署：\n\n![](https://pic.yupi.icu/1/image-20240429133015557.png)\n\n还可以查看服务日志、资源占用情况：\n\n![](https://pic.yupi.icu/1/image-20240429132931155.png)\n\n虽然微信云托管平台感觉很久没更新了，配置容器的灵活性也没那么高，但是能够满足大多数开发者的使用诉求了。\n\n\n\n## 升级过程\n\n### 1、后端服务迁移\n\n既然后端服务要部署到容器平台，肯定要把项目制作为 Docker 镜像。\n\n方法很简单，在后端项目根目录创建一个 `Dockerfile` ，编写构建镜像的命令即可。\n\n比如 Spring Boot 项目可以使用类似下面的配置：\n\n```sh\n# 选择基础镜像\nFROM maven:3.8.1-jdk-8-slim as builder\n\n# 解决容器时期与真实时间相差 8 小时的问题\nRUN ln -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo Asia/Shanghai > /etc/timezone\n\n# 复制代码到容器内\nWORKDIR /app\nCOPY pom.xml .\nCOPY src ./src\n\n# 打包构建\nRUN mvn package -DskipTests\n\n# 容器启动时运行 jar 包\nCMD [\"java\",\"-jar\",\"/app/target/server.jar\",\"--spring.profiles.active=prod\"]\n```\n\n这里有个比较坑的地方，要注意容器环境的时间，有可能会和真实时间相差 8 小时，导致日志时间、以及插入到数据库的时间错误。\n\n\n\n### 2、配置 CDN\n\n配置 CDN 的关键是配置源站的地址。CDN 相当于是缓存，如果用户需要的数据在 CDN 上找不到，CDN 节点就会请求源站来获取数据，所以源站配置一定不能错。\n\n![](https://pic.yupi.icu/1/image-20240429134157358.png)\n\n上图中的回源设置，是指 CDN 请求源站的方式，包括协议、域名端口号等。\n\n这里有 2 个注意事项：\n\n1）避免给源站添加任何的重定向逻辑，否则可能重定向时直接暴露了源站地址。\n\n比如 cdn 地址是 \"yupi.icu\"，源站地址是 \"base.yupi.icu\"，一般源站地址是要隐藏起来的，否则用户就可以绕过 CDN 直接攻击你的源站。如果源站配置了重定向逻辑，比如将后缀 \"/\" 路由到 \"/aaa\"。那么用户在访问 \"yupi.icu/\" 时，可能会被自动重定向到 \"base.yupi.icu/aaa\"！暴露了！\n\n2）如果 CDN 站点开启了 HTTPS，回源协议尽量用 HTTP，否则可能会出现因为相同证书子域名 SSL 配置不一致导致的 421 错误（Misdirected Request），这个错误可以说是非常冷门了，不自己上线个项目，大概率听都没听说过。\n\n\n\n### 3、配置 DNS\n\n打通 CDN 到源站（容器平台）的访问后，最后一步就是配置 DNS，让用户访问的域名（比如 www.code-nav.cn）解析到 CDN。\n\n需要注意的是，DNS 的解析生效时长在全国各地是不等的，所以有可能更改解析后，北京的用户访问不了、上海的用户能访问。所以不要急着把老服务下线掉！\n\n本来以为很顺利，结果呢，CDN 访问源站竟然失败了，源站返回了 444 错误码（连接已关闭）！又是一个冷门的错误！\n\n这个错误可把我折腾坏了，为啥我的服务器会拒绝国内 CDN 节点的连接呢？首先第一个猜测就是服务器封禁了 IP，于是查了高防、查了服务器防火墙、还咨询了云服务商的客服，结果都说没有封禁 IP。。。\n\n![](https://pic.yupi.icu/1/image-20240429135434226.png)\n\n于是，我去看了下 Nginx 的日志：\n\n```\nCDN 节点的 IP - - [29/Apr/2024:00:06:41 +0800] \"GET /favicon.ico HTTP/1.1\" 444 0 \"https://www.code-nav.cn/\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36\"\n```\n\nNginx 既然已经收到了请求，说明大概率是 Nginx 配置拒绝了连接。但是我翻烂了 Nginx 的配置，也没找到在哪配置了 IP 封禁。。。\n\n最后你猜怎么着？我突然想起来几年前，我曾经在这个服务器上购买过 Nginx 防火墙。虽然它早已过期，但貌似还能帮我自动封禁一些 IP。。。估计是因为昨天配 CDN 时我为了测试验证，使得访问源站频率过高导致的。\n\n于是我把 Nginx 防火墙卸载了，就没有这个错误了。\n\n![](https://pic.yupi.icu/1/image-20240429135912255.png)\n\n用 4 个字来形容，我想到了 “阴魂不散”。\n\n\n\n---\n\n\n\n以上就是本期分享。当然，实际的升级过程，可比我这篇文章描述地还要麻烦，因为还涉及到一些平台（比如微信公众平台）的白名单配置。而且我们升级肯定是需要灰度的，先拿访问量最低的项目去验证流程，再陆续迁移其他项目。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/EM40np55-升级了项目的部署方式，坑死我了！.jpeg",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 38,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-05-06 19:20:30",
        "updateTime": "2024-05-08 09:44:15",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3095,
          "coin": 170,
          "followeeNum": 1510,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2287-05-20 01:46:39",
          "lastLoginTime": null,
          "createTime": "2022-12-09 12:32:33",
          "updateTime": "2024-05-08 10:43:13"
        },
        "tags": [
          "文章",
          "技术"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1787092220336275457",
        "title": "挑战一篇文章通俗易懂讲清楚 React Element、React Component、JSX、Fiber，Diff算法",
        "description": "记录学习 React 源码过程中，不好理解的地方，本篇讲解 React Element、React Component、JSX、FIber、Diff 算法、React.createElement 等",
        "content": "## 五一快乐！\n\n大家五一快乐，不知道大家有没有五一玩了很多天后，内心一点点负罪感，需要赶紧学点干货，对冲一下五一的玩乐。不如看一下这篇文章，复习(学习）一下 React 中经常被提起的概念。\n最近在学习 React 源码的时候，发现好多概念，它们之间还有一些关系。总是容易忘记和弄混，打算写一篇文章记录一下，忘记了就再翻看看看。这次要弄清楚的是\n\n- React Element\n- React Component\n- JSX\n- Fiber\n- Diff 算法\n- React.createElement\n\n我会先介绍一下以上每一个，然后再通过源码和工具，来理解它们的关系，来我们先看看它们的“自我简介”\n\n## 它们的“自我简介”\n\n### React Element\n\n`React Element` 是构建 React 应用的最小单元。它是对一个 DOM 元素的轻量级描述，**最后都会被转化为纯 JavaScript 对象**，\n`React Element` 对象包含了几个基本的属性，如：\n\n- type：表示元素的类型，可以是字符串（如 'div', 'span' 等 HTML 元素），也可以是一个 React 组件。\n- props：包含了该元素的属性，以及传递给子元素的数据。\n- key：一个可选的、在兄弟元素之间必须唯一的字符串，用于在重新渲染时帮助识别元素的稳定性。\n\n`React Element`是不可变的，一旦被创建，你不能改变其内容或属性。如果界面需要更新，React 会创建一个新的 Element，并在必要时通过比较新旧 `Elements` 来有效地更新 DOM。\n因此，可以将 `React Element` 理解为描述界面结构的纯数据结构，它们是虚拟 DOM 的组成部分，用于最终生成真实的 DOM 结构。这种设计使得 React 可以在不直接操作 DOM 的情况下，通过比较和重新渲染 `Elements` 来高效地更新界面。给大家看一下一个真实的`React Element` 对象是什么样子的：\n\n```javascript\n// <div classname=\"snail-run\">snailRun</div>;\n// JSX 转化为 React ELement 的对象如下：\n{\n  '$$typeof': Symbol(react.transitional.element),\n  type: 'div',\n  key: null,\n  props: { classname: 'snail-run', children: 'snailRun' },\n  _owner: null,\n  _store: {}\n}\n```\n\n### React Component\n\n`React Component` 是构成 React 应用的独立、可复用的代码块。它们本质上是返回 `React Element`的 `JavaScript` 函数或类。组件可以接受输入（称为 `props`），并返回`React Element`。组件分为两种类型：函数组件和类组件，函数组件通常更简洁，支持 Hooks。它还可以作为 `React.createElement`的第一个参数，也就是 type 字段。我们日常开发 React 项目，写的最多的也就是 `React Component`,给大家写一下最简单的函数组件和类组件：\n\n```jsx\n// 函数组件\nfunction AppFunc() {\n  // 可以使用 react hooks\n  return <div>snailRun</div>;\n}\n// 类组件\nclass AppClass extends React.Component {\n  render() {\n    return <div>snailRun</div>;\n  }\n}\n```\n\n### JSX\n\nJSX是一种语法扩展（语法糖），看起来很像 `XML`或 `HTML`。`JSX`提供了一种更直观的方式来描述UI，它让开发者可以在 `JavaScript`代码中写标签语言。在编译过程中，`JSX`会被转换成标准的`JavaScript`对象，即 `React Elements`，JSX 示例代码：\n\n```jsx\n<div classname=\"name\">snailRun</div>\n```\n\n### Fiber\n\n`Fiber` 是一种新的内部架构，用于增强 React 的能力，特别是在动画、布局和中断渲染方面。`Fiber`架构首次在 `React 16`中引入，目的是解决以前版本 React 递归更新过程不能中断的问题，**它能够将渲染工作分解成小的单元，每完成一小部分工作后，就能将控制权交回给浏览器，让浏览器处理如动画、布局、输入响应等其他工作。这种能力被称为“可中断渲染”**。Fiber 作为静态数据结构来讲，存储着很多信息，和 JSX 数据结构很相似，但是它存储更多内容。它本质上是一个**工作单元**的抽象，它代表 React 在构建和更新 DOM 时需要完成的工作。每一个 `React Element` 都对应一个 **Fiber 节点**，整个应用的结构可以被看作一个巨大的 Fiber 树。想看一个 fiber 树的数据结构的话请看：https://react.iamkasong.com/process/fiber.html\n\n### Diff 算法\n\n当组件的状态或属性发生变化时，React 需要决定是否更新 DOM。React 使用** Diff 算法**来比较新旧两个 fiber 树并标记标记那些需要进行添加、删除或更新的 Fiber 节点并确定优先级，最后提交更改到 DOM，这个过程称为 `Reconciliation`（协调）。\n\n**Diff 算法**会识别出需要进行更新的部分，并生成相应的操作来更新 DOM。这种方法确保了只有实际改变的部分才会被重新渲染，从而优化了性能。\n\n> 小知识 >> 首屏渲染和更新的区别是：在创建 fiber 树的过程中，是否有diff算法\n\n## 通过源码学习\n\n想要了解这些名词和它们之间的关系，我们需要借助一个 JavaScript 编译器 `babel`：[https://babeljs.io/](https://babeljs.io/)，来看看 JSX 的编译结果。首先我们不添加任何插件，来写一段 JSX 代码，我们可以看到报错了，因为本来`JavaScript` 不知道如何编译 JSX 的。 \n\n![image.png](https://pic.code-nav.cn/zhishizhushou/post/1681154136362307586/2HqSDITk-image.png)\n我们这时候滑动左边到底部点击 `add plugin` ，添加一个 `transform-react-jsx`插件。\n\n![image.png](https://pic.code-nav.cn/zhishizhushou/post/1681154136362307586/yd8M3ENA-image.png)\n我们可以看到，JSX 语法被成功编译，我们的左侧就被编译成为了右侧，它的结果就是 JSX 的结果：\n\n![image.png](https://pic.code-nav.cn/zhishizhushou/post/1681154136362307586/rRr4NjPx-image.png)\n那我们现在来看看编译后的这个代码的结果是什么？也就是`React.createElement`做了什么？我帮大家找到了 React 源码中 `React.createElement`的实现，也就是下面这段代码：\n\n```javascript\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      let info = '';\n      if (\n        type === undefined ||\n        (typeof type === 'object' &&\n          type !== null &&\n          Object.keys(type).length === 0)\n      ) {\n        info +=\n          ' You likely forgot to export your component from the file ' +\n          \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      let typeString;\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = `<${getComponentNameFromType(type.type) || 'Unknown'} />`;\n        info =\n          ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      console.error(\n        'React.createElement: type is invalid -- expected a string (for ' +\n          'built-in components) or a class/function (for composite ' +\n          'components) but got: %s.%s',\n        typeString,\n        info,\n      );\n    } else {\n      // This is a valid element type.\n\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      for (let i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], type);\n      }\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidRef(config)) {\n      if (!enableRefAsProp) {\n        ref = config.ref;\n        if (!disableStringRefs) {\n          ref = coerceStringRef(ref, getOwner(), type);\n        }\n      }\n\n      if (__DEV__ && !disableStringRefs) {\n        warnIfStringRefCannotBeAutoConverted(config, config.__self);\n      }\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        (enableRefAsProp || propName !== 'ref') &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        if (enableRefAsProp && !disableStringRefs && propName === 'ref') {\n          props.ref = coerceStringRef(config[propName], getOwner(), type);\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key || (!enableRefAsProp && ref)) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n      if (!enableRefAsProp && ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  const element = ReactElement(\n    type,\n    key,\n    ref,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n  );\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  }\n\n  return element;\n}\n```\n\n现在让我来简单解释一下这段代码：\n**参数说明：**\n\n- type：元素的类型，可以是 HTML 标签的字符串，或者是一个 React 组件（ 函数组件 和 类组件）\n- config：一个配置对象，包含了元素的属性（props），可能还包括特殊属性如 key 和 ref。\n- children：子元素，可以是任意数量的参数，表示元素的子节点。\n\n示例：`React.createElement(\"div\", {classname: \"snail-run\"}, \"snailRun\");`\n**主要逻辑：**\n\n1. **类型验证**：首先检查 type 是否有效。如果无效，会在控制台输出错误信息。有效性检查包括是否未定义、是否为空对象、是否为数组等情况。\n2. **处理配置对象（config）**：\n   - **处理 ref**：如果配置对象中有 ref 属性，并且当前环境允许 ref 作为属性，那么将其添加到新的 props 对象中。\n   - **处理 key**：如果配置对象中有 key 属性，将其转换为字符串并存储。\n   - **复制其他属性**：将 `config` 对象中的其他属性复制到新的 props 对象中，忽略 `key、ref、__self `和 `__source` 等特殊或保留属性。\n3. **处理子元素**：\n   - 如果只有一个子元素，直接将其赋值给 `props.children`。\n   - 如果有多个子元素，将它们放入一个数组中，并赋值给 `props.children`。\n4. **处理默认属性**：如果类型 type 有默认属性（`defaultProps`），则将未在 props 中显式设置的属性填充为默认值。\n5. **创建 React Element**：使用 `ReactElement` 函数创建一个新的 React 元素，传入 `type、key、ref、props `等参数。\n6. **特殊类型处理**：如果 type 是 `Fragment` 类型，还会对 `Fragment` 的属性进行验证。\n\n**开发与生产环境的差异**\n代码中多次出现` __DEV__ `的条件编译指令，这是用来区分开发环境和生产环境的。在开发环境中，会进行更多的警告和错误检查，以帮助开发者发现潜在问题。\n**总结：**\n\n- `createElement` 函数接受参数后，通过校验参数和处理，最后返回了 `ReactElement`，也就是说 JSX 编译得到的结果是 `ReactElement`，\n- **JSX **是写 React 组件时用来声明元素的语法糖，本质是 `React.createElement`，最终 JSX 被转换成 `React Element`。\n\n## 它们的关系\n\n1. **JSX 与 React Element 的关系**： `JSX` 是 `JavaScript` 的语法扩展，看起来很像 `HTML`。开发者通常使用 `JSX` 来描述 `UI` 结构。当 `JSX` 被编译时，它会被转换成 `React Element`。因此，可以认为 `JSX `是创建 `React Element` 的语法糖。\n2. **React Element 与 React Component 的关系**： `React Element` 是 `React`应用中最小的构建块，它是对组件输出的轻量级描述。`React Component` 则是封装了逻辑和状态的独立单元，它返回 `React Element`。因此，组件是创建和管理元素的容器。\n3. **React Element 和 Fiber 节点的关系**：每个 `React Element`在内部对应一个 `Fiber` 节点，这些节点是实际执行工作的单位。\n4. **React Component 和 Fiber 的关系**： 在` React 16` 版本中引入了 `Fiber` 架构，这是一种新的协调算法，用于提高应用的性能和响应性。每个 `React Component` 在渲染时都会对应**一个或多个** `Fiber` 节点。`React` 中的一个**工作单元**通常是一个 `Fiber`节点，`React` 通过这些**工作单元**来构建和更新虚拟 `DOM`。\n5. **Diff 算法比较 Element 变化**：当组件的状态或属性变化时，`React`会使用 `Diff`算法比较旧的和新的 `React Element`，确定哪些需要更新。\n6. **Fiber 与 Diff 算法的关系**： `Diff` 算法是 `React` 中**用于对比新旧虚拟 DOM 的差异，并决定如何有效更新真实 DOM 的过程**。在 `Fiber` 架构中，`Diff` 算法被用于确定哪些 `Fiber` 节点需要变更、哪些可以保留。`Fiber` 架构使得 `React` 可以中断和恢复 `Diff` 过程，允许任务按优先级进行，从而优化性能。\n7. **整体流程**： 当组件的状态或属性发生变化时，`React` 会重新执行 通过 `JSX`（`React.createElement` 语法糖） 创建的组件（`React Component`）的渲染函数，生成新的 `React Element`。然后，`React` 使用 **Diff 算法**对比新旧元素，通过** Fiber 架构**将这些变更分解成多个小任务，逐步执行这些任务，生成新的 `fiber` 树，最终将变更反映到真实的 `DOM` 上。\n\n总结来说，**JSX **提供了一种声明式的语法来生成 `React Element / React Component`（函数组件 or 类组件），这些元素是由 `React Component` 输出的。`React Component` 通过** Fiber 架构**管理其生命周期和状态变化，而 `Fiber` 架构内部使用** Diff 算法**来优化更新过程。这些概念共同工作，使得 `React` 能够高效且灵活地构建用户界面。\n\n## 参考\n\n1. React 技术解密：[https://react.iamkasong.com/preparation/jsx.html#jsx-%E7%AE%80%E4%BB%8B](https://react.iamkasong.com/preparation/jsx.html#jsx-%E7%AE%80%E4%BB%8B)\n2. ai 问答：[https://devv.ai/search?threadId=dkrfa9t4dwxs](https://devv.ai/search?threadId=dkrfa9t4dwxs)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/F84gpXhx-React源码学习1.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 19,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-05-05 20:09:22",
        "updateTime": "2024-05-07 21:43:40",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "admin",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 40,
          "coin": 0,
          "followeeNum": 23,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-04-13 22:37:59",
          "lastLoginTime": null,
          "createTime": "2023-01-30 13:30:01",
          "updateTime": "2024-05-06 20:10:25"
        },
        "tags": [
          "文章",
          "React",
          "笔记"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1787030495389941761",
        "title": "网站访问速度提升93.8%只因我做了这件事!",
        "description": "打开控制台发现主要原因是`chunk-vendors.js`文件太大，导致加载速度慢",
        "content": "\n哈喽大家好，我是一名软件工程专业的在校生，第一次做完整的前后端分离项目，第一次把网站上线。\n\n\n当我开心地在浏览器输入地址，但访问首页要`8秒多`好慢啊！！！\n\n打开控制台发现主要原因是`chunk-vendors.js`文件太大，导致加载速度慢\n\n![image_爱奇艺.jpg](https://pic.code-nav.cn/post_picture/1745818211997196290/fssS7hpY-image_爱奇艺.jpg)\n\n接着在网上查阅资料，   \n>第一个方案是 **使用optimization.splitChunks做分包**\n\n需要修改vue.config.js文件\n\n```js\nconfigureWebpack: {\n  optimization: {\n    // 将运行时代码提取为单独的 chunk，以便更好地利用缓存\n    runtimeChunk: 'single',\n    // 将第三方库和业务代码分割到不同的 chunk 中，以便更好地利用浏览器的并行加载机制\n    splitChunks: {\n      chunks: 'all', // 表示对所有模块进行代码分割\n      maxInitialRequests: Infinity, // 没有最大的初始化请求限制\n      minSize: 20000, // 模块的最小大小，小于此值的模块不会被拆分\n      maxSize: 60000, // 模块的最大大小，大于此值的模块会被拆分\n      cacheGroups: {\n        vendors: {\n          // 指定匹配的模块来源\n          test: /[\\\\/]node_modules[\\\\/]/,\n          // 设置优先级，防止和自定义的公共模块提取时被覆盖，值越大优先级越高\n          priority: -10,\n          // 重命名提取出来的 chunk 名，此处取自 node_modules 文件夹下的模块名\n          name(module) {\n            const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/)[1];\n            return `npm.${packageName.replace('@', '')}`;\n          },\n        },\n      },\n    },\n  },\n}),\n\n```\n访问速度缩短为`4.4秒`\n\n![微信截图_20240505143308.png](https://pic.code-nav.cn/post_picture/1745818211997196290/dypvhpgm-微信截图_20240505143308.png)\n\n但是还是有点慢，继续优化！ \n\n> 第二个方案是**压缩代码**，同时需要修改nginx配置\n\n安装`compression-webpack-plugin`插件。\n\n```js\nyarn add compression-webpack-plugin --save-dev\n```\n前端将文件打包成`.gz`文件，然后通过`nginx`的配置，让浏览器直接解析`.gz`文件，可以大大提升文件加载的速度。\n\n需要修改`vue.config.js`文件\n\n```js\nconfigureWebpack: {\n  plugins: [\n    new CompressionPlugin({\n      // 压缩后的文件名\n      filename: '[path][base].gz',\n      // 压缩算法，这里使用gzip\n      algorithm: 'gzip',\n      // 匹配需要压缩的文件类型，这里匹配js和css文件\n      test: new RegExp(\n          '\\\\.(js|css)$'\n      ),\n      // 只有文件大小大于等于这个值的文件才会被压缩，单位是字节，默认为0\n      threshold: 10240, // 10 KB\n      // 压缩率，只有压缩率达到或超过这个值的文件才会被压缩，默认是0.8\n      minRatio: 0.8,\n    }),\n  ],\n},\n\n```\n需要修改`nginx.config`文件,读取压缩后的文件\n\n```js\nserver {\n    gzip on; // 开启gzip压缩\n    gzip_min_length 1k; // 只压缩大于1KB的文件\n    gzip_comp_level 9; // 压缩级别，级别越高压缩率越高，但消耗CPU资源也越多\n    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; // 指定需要进行gzip压缩的文件类型\n    gzip_vary on; // 根据Accept-Encoding请求头决定是否启用压缩，防止CDN缓存问题\n    gzip_disable \"MSIE [1-6]\\.\"; // 禁用gzip压缩的浏览器类型，这里禁用了IE6及以下的浏览器\n    // 其余配置\n}\n\n```\n访问速度缩短为`542毫秒`，1秒以内！\n\n![1714891517324.png](https://pic.code-nav.cn/post_picture/1745818211997196290/XZ1skJH1-1714891517324.png)\n\n\n还有什么解决方案呢？\n还可以使用`CDN`继续优化，或者综合使用前面的两种方法。\n\n提升了多少呢？问一下AI吧；\n\n![1714891517324.png](https://pic.code-nav.cn/post_picture/1745818211997196290/VSGwRTP5-1714891517324.png)\n\n好啦，标题也有了哈哈(๑•̀ㅂ•́)و✧     \n本篇文章到此结束\uD83D\uDD1A\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1745818211997196290/U7ffGBak-image_爱奇艺.jpg",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 26,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1745818211997196290",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-05-05 16:04:06",
        "updateTime": "2024-05-08 11:32:14",
        "user": {
          "id": "1745818211997196290",
          "planetCode": "28784",
          "userName": "望舒",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1745818211997196290/ogBe4Dhd-default_avatar.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": "软件",
          "education": "本科",
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 0,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-10-27 22:14:30",
          "lastLoginTime": null,
          "createTime": "2024-01-12 22:41:12",
          "updateTime": "2024-05-05 16:05:01"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1785879499670421505",
        "title": "Gradle 进阶学习之 Gradle插件",
        "description": "使用插件是现代自动化构建工具中一个非常重要的概念，Gradle 作为其中一个流行工具，通过插件提供了多种便利。以下是使用插件的几个主要原因：",
        "content": "# 1、使用插件的原因\n\n使用插件是现代自动化构建工具中一个非常重要的概念，Gradle 作为其中一个流行工具，通过插件提供了多种便利。以下是使用插件的几个主要原因：\n\n1. 促进代码重用\n\n   - **减少重复代码**：插件允许你重用在不同项目中执行相同功能的代码，减少了编写和维护相似代码的需要。\n\n   - **标准化流程**：插件通常封装了一组标准化的操作，使得在多个项目间实现构建流程的一致性变得更加容易。\n\n\n2. 提升工作效率\n\n   - **快速实现功能**：插件通常提供了一组预定义的任务，可以快速实现打包、测试、部署等功能，从而加速开发流程。\n\n   - **简化构建配置**：通过应用插件，可以避免编写复杂的构建脚本，因为插件已经提供了所需的配置。\n\n\n3. 项目模块化\n\n   - **解耦功能**：插件使得特定的构建功能模块化，这样可以更容易管理和更新这些功能，而不会影响到项目的核心构建脚本。\n\n   - **清晰的构建逻辑**：模块化还有助于保持构建逻辑的清晰，使得构建脚本更易于理解和维护。\n\n\n4. 自动化和便捷化\n\n   - **自动化流程**：插件可以自动化许多繁琐的构建任务，让开发者专注于更重要的业务逻辑。\n\n   - **用户友好**：许多插件提供了便捷的命令和配置选项，使得构建过程更加用户友好。\n\n\n5. 扩展项目功能\n\n   - **即插即用**：插件的可插拔特性意味着你可以轻松地为项目添加新的功能，而无需深入了解实现细节。\n\n   - **社区支持**：Gradle 拥有一个活跃的社区，提供了大量的插件，可以扩展构建系统的功能，满足特定的构建需求。\n\n\n6. 维护和更新\n\n   - **持续集成**：许多插件支持持续集成（CI）流程，可以与 Jenkins、Travis CI 等工具集成，自动化测试和构建流程。\n\n   - **易于更新**：插件的更新通常比核心构建系统更容易，因为它们是独立的组件。\n\n\n# 2、插件的作用\n\n插件在 Gradle 构建系统中扮演着至关重要的角色，它们为项目提供了额外的功能和自动化能力。以下是插件在项目构建过程中可以完成的一些事情：\n\n1. 添加任务（Task）\n\n   - **自定义任务**：插件可以向项目中添加新的任务，这些任务可以是执行测试、编译源代码、打包应用程序等。\n\n   - **任务配置**：插件还可以预配置某些任务，使得开发者不需要手动设置所有参数。\n\n\n2. 添加依赖配置\n\n   - **管理依赖**：插件可以帮助定义项目的依赖管理，包括外部库依赖、项目内部模块依赖等。\n\n   - **远程仓库**：插件可以配置远程仓库，如 Maven Central 或 JCenter，以便下载所需的库。\n\n\n3. 扩展项目属性和方法\n\n   - **扩展属性**：插件可以向项目添加新的属性，这些属性可以用于控制构建过程或存储配置信息。\n\n   - **扩展方法**：插件可以向项目添加新的方法，这些方法可以用于执行特定的构建逻辑或封装复杂的操作。\n\n\n4. 项目约定\n\n   - **目录结构**：应用特定的插件，如 Java 插件，会为项目设置一些默认的目录结构约定，例如 `src/main/java` 作为源代码目录。\n\n   - **构建生命周期**：插件还可以定义构建过程中的特定阶段，例如编译、测试、打包和部署。\n\n\n\n\n插件是 Gradle 强大的扩展机制，它们可以极大地简化构建配置，提供最佳实践，并允许开发者通过标准化的方式来构建项目。通过应用插件，你可以快速获得构建、测试、打包和依赖管理等自动化功能，同时保持项目的灵活性和可维护性。\n\n\n\n# 3、插件的分类和使用\n\n![image-20240420202646427](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420202646427.png)\n\n## 3.1 脚本插件\n\n在 Gradle 中，脚本插件是一种允许你通过外部 Groovy 脚本文件来扩展构建逻辑的方法。这些脚本可以定义变量、任务、配置等，并且可以通过 `apply from` 语句被导入到主构建脚本中。\n\n### 3.1.1 脚本插件的创建\n\n1. **创建外部脚本文件**：你可以创建一个包含 Groovy 代码的文件，比如 `version.gradle`。\n\n```groovy\n// version.gradle\next {\n    company = \"阿杰\"\n    cfgs = [\n            compileSdkVersion: JavaVersion.VERSION_21\n    ]\n    spring = [\n            version: '6.0.0'\n    ]\n}\n```\n\n在这个脚本中，我们使用了 `ext` 来定义了一系列的属性，这些属性在导入脚本后可以在构建脚本中使用。\n\n### 3.1.2 脚本插件的应用\n\n2. **在构建脚本中应用脚本插件**：在你的 `build.gradle` 文件中，使用 `apply from` 来加载外部脚本。\n\n```groovy\n// build.gradle\napply from: 'version.gradle'\n\ntask taskVersion {\n    doLast {\n        println \"博主的昵称：${company}, JDK版本是${cfgs.compileSdkVersion}, 版本号是${spring.version}\"\n    }\n}\n```\n\n在这个构建脚本中，我们应用了之前创建的 `version.gradle` 脚本。然后我们定义了一个名为 `taskVersion` 的任务，它会在执行时打印出从脚本插件中导入的变量。\n\n3. **运行构建**：在命令行中运行 Gradle 构建，执行 `taskVersion` 任务。\n\n```shell\ngradle taskVersion\n```\n\n![image-20240420203619061](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420203619061.png)\n\n执行上述命令后，Gradle 会加载并执行 `build.gradle` 文件中的指令，包括应用外部脚本插件和执行 `taskVersion` 任务。\n\n### 3.1.3 注意事项\n\n- **脚本位置**：确保外部脚本文件的位置是正确的，并且 Gradle 能够找到它。\n- **安全性**：从网络上加载脚本时要注意安全性，确保脚本来源可靠，避免执行恶意代码。\n\n### 总结\n\n脚本插件是 Gradle 提供的一种灵活的扩展机制，允许你通过外部 Groovy 脚本来添加构建逻辑。这种方式非常适合于在多个项目之间共享配置或创建自定义的构建行为。通过使用脚本插件，可按功能把我们的脚本进行拆分一个个公用、职责分明的文件，然后在主脚本文件引用，\n\n比如：将很多共有的库版本号一起管理、应用构建版本一起管理等。可以使构建脚本更加模块化和可重用。\n\n## 3.2 对象插件\n\nGradle 的对象插件，也称为二进制插件或 Java 插件，是通过实现 `org.gradle.api.Plugin` 接口的 Java 类来提供的。这些插件为项目提供了特定的构建功能，并且可以通过一个唯一的插件 ID 来应用到项目中。\n\n![image-20240420204109332](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420204109332.png)\n\n### 3.2.1 内部插件[核心插件]\n\nGradle 提供了一系列的核心插件，这些插件覆盖了多种常见的构建需求，包括但不限于：\n\n- **Java**：支持构建任何类型的 Java 项目。\n- **C++ Application**：支持在 Windows、Linux 和 macOS 上构建 C++ 应用程序。\n- **Application**：支持构建基于 JVM 的可运行应用程序。\n- **WAR**：支持构建和打包基于 WAR 的 Java Web 应用程序。\n- **Checkstyle**：使用 Checkstyle 对项目中的 Java 源文件执行质量检查。\n- **Eclipse**：为构建生成 Eclipse 项目文件。\n- **IntelliJ IDEA**：为构建生成 IDEA 项目文件。\n\n**查找核心插件：**\n\n要查找 Gradle 提供的所有核心插件，可以访问官方文档中的插件参考页面：\n\n- [Gradle 官方插件参考](https://docs.gradle.org/current/userguide/plugin_reference.html)\n\n在这里，你可以找到每个插件的描述、提供的配置和如何应用该插件的指导。\n\n#### 使用 Java 插件\n\n以下是几种应用 Java 插件到项目中的方法：\n\n1. **使用插件 ID**：\n\n   ```\n   apply plugin: 'java'\n   ```\n\n   这是应用 Java 插件的推荐方式，简洁且易于理解。\n\n2. **使用闭包**：\n\n   ```\n   apply {\n       plugin 'java'\n   }\n   ```\n\n   这种方式使用了一个闭包来包裹插件 ID，这在需要应用多个插件时非常有用。\n\n3. **使用全类名**：\n\n   ```\n   apply plugin: org.gradle.api.plugins.JavaPlugin\n   ```\n\n   这种方式直接指定了插件的完整类名，这在 IDE 中自动完成代码时可能会看到。\n\n4. **使用导入的类**：\n\n   ```\n   apply plugin: JavaPlugin\n   ```\n\n   如果 `org.gradle.api.plugins` 包已经被导入，你可以直接使用类名来引用插件。\n\n> 插件 ID 的唯一性：\n>\n> 每个插件都有一个唯一的插件 ID，这有助于避免名称冲突。通常，插件 ID 会采用应用包名来确保其唯一性，如 `java` 对应的完整类名为 `org.gradle.api.plugins.JavaPlugin`。\n\n### 3.2.2 第三方插件\n\n在使用第三方发布的二进制插件时，通常需要确保 Gradle 能够从正确的仓库中获取这些插件。以下是两种常见的方法来应用这些插件：\n\n#### 1.  传统应用方式\n\n使用 `buildscript` 块，你需要指定插件的类路径和仓库：\n\n```groovy\nbuildscript {\n    ext {\n        springBootVersion = \"2.3.3.RELEASE\"\n    }\n    repositories {\n        mavenLocal()\n        maven { url 'http://maven.aliyun.com/nexus/content/groups/public' }\n        jcenter()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")\n    }\n}\n\napply plugin: 'org.springframework.boot'\n```\n\n在这个例子中，我们首先定义了 `buildscript` 块，它告诉 Gradle 从哪里查找插件。`repositories` 块可以包含多个仓库，这里包括了 Maven 本地仓库、阿里云的 Maven 仓库和 JCenter。\n\n#### 2. plugins DSL 方式\n\nGradle 引入了一种新的 `plugins` 块，它提供了一种更简洁的方式来应用插件，特别是当插件被托管在 [Gradle 插件仓库](https://plugins.gradle.org/) 时：\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.4.1'\n}\n```\n\n使用 `plugins` 块时，Gradle 会自动从 Gradle 插件仓库中解析插件的坐标，因此你不需要显式地指定类路径和仓库。\n\n#### 3. 注意事项\n\n1. **位置**：在使用传统方式时，`buildscript` 块必须位于 `build.gradle` 文件的顶部。而 `plugins` 块则没有这个限制，可以放在文件的任何位置。\n\n2. **格式**：`plugins` 块使用 `id` 和 `version` 来指定插件的 ID 和版本，这使得构建脚本更加清晰和易于管理。\n\n3. **自动解析**：当使用 `plugins` 块时，Gradle 会自动解析插件的坐标，这意味着你不需要手动添加仓库和类路径。\n\n4. **兼容性**：确保你使用的 Gradle 版本与第三方插件的版本兼容。\n\n#### 总结\n\n使用 `plugins` 块可以简化插件的应用过程，特别是当你使用托管在 Gradle 插件仓库中的插件时。这种方式使得构建脚本更加简洁，同时减少了配置错误的可能性。然而，在一些情况下，你可能仍然需要使用传统的 `buildscript` 方法，比如当插件不是托管在 Gradle 插件仓库中，或者你需要自定义插件的类路径和仓库时。\n\n### 3.2.3 用户自定义插件\n\n在 Gradle 中，用户自定义插件是一种强大的扩展构建功能的方式。自定义插件允许你封装逻辑，创建新的任务，甚至向项目添加自定义的扩展属性和方法。这些插件可以用于单个项目，也可以被设计为可重用和可共享的。\n\n#### 1. 示例\n\n```groovy\n/**\n * GreetingPluginExtension 接口定义了问候插件的扩展属性。\n * 这个接口规定了插件配置中可以使用的两个属性：getMessage 和 getGreeter。\n */\ninterface GreetingPluginExtension {\n    // getMessage 方法：获取问候语。\n    Property<String> getMessage()\n    // getGreeter 方法：获取发出问候的实体。\n    Property<String> getGreeter()\n}\n\n/**\n * GreetingPlugin 类实现了 Plugin 接口，为 Gradle 提供了一个问候插件。\n * 这个插件向项目中添加了一个 'hello' 任务，该任务在执行时会打印一条问候语。\n */\nclass GreetingPlugin implements Plugin<Project> {\n    /**\n     * apply 方法将插件应用到指定的项目上。\n     * @param project 要应用插件的项目实例。\n     */\n    void apply(Project project) {\n        // 创建一个名为 'greeting' 的插件扩展，允许用户自定义问候语和发出问候的实体。\n        def extension = project.extensions.create('greeting', GreetingPluginExtension)\n\n        // 创建一个名为 'hello' 的任务，任务执行时会打印配置的问候语。\n        project.task('hello') {\n            doLast {\n                // 打印问候语，使用插件扩展中配置的消息和发出问候的实体。\n                println \"${extension.message.get()} from ${extension.greeter.get()}\"\n            }\n        }\n    }\n}\n\n// 应用 GreetingPlugin 插件到当前的 Gradle 项目中。\napply plugin: GreetingPlugin\n\n// 配置插件扩展，设置问候语和发出问候的实体。\ngreeting.message = 'Hello from plugin'\ngreeting.greeter = 'Gradle'\n```\n\n![image-20240420212341025](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420212341025.png)\n\n#### 2. 用户自定义插件的局限性\n\n虽然用户自定义插件非常灵活，但它们通常局限于定义它们的项目。这意味着，如果你在一个项目中定义了一个自定义插件，它可能不适用于其他项目，除非你将插件逻辑提取到一个独立的类或 JAR 文件中，并在其他项目中包含这个类或 JAR 文件。\n\n#### 3. 共享自定义插件\n\n为了使自定义插件可重用和共享，你可以：\n\n- **构建独立插件**：将插件代码放入一个独立的项目中，构建为 JAR 文件，然后发布到本地仓库或远程仓库。\n- **使用 `buildSrc`**：对于小型或特定于项目的插件，可以将插件代码放置在项目的 `buildSrc` 目录中。这样，插件可以被当前项目和子项目使用。\n\n#### 总结\n\n自定义插件是 Gradle 插件系统的重要组成部分，它们允许开发者根据自己的需求扩展构建过程。通过创建自定义插件，你可以增加新的构建任务，定义配置选项，甚至提供全新的构建逻辑。自定义插件的开发需要对 Gradle 插件机制有深入的理解，并且需要遵循一定的设计原则以确保插件的可重用性和可维护性。\n\n# 4、buildSrc 项目\n\n`buildSrc` 是 Gradle 提供的一个特殊目录，用于存放构建过程中使用的自定义 Groovy 插件和脚本。这个目录被视为一个独立的 Gradle 项目，你可以在这个目录下编写自己的插件和脚本，它们可以在整个构建过程中被重用。 \n\n以下是如何使用 `buildSrc` 目录的步骤：\n\n## 4.1 创建 `buildSrc` 模块\n\n![。](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502095946202.png)\n\n将 buildSrc 从 included modules 移除,重新构建。\n\n![image-20240502100124262](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502100124262.png)\n\n然后只保留 build.gradle 和 src/main 目录，其他全部删掉\n\n![image-20240502100230541](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502100230541.png)\n\n## 4.2 然后修改 Gradle 中的内容\n\n```groovy\nplugins {\n    id 'java'\n    id 'groovy' // 必须\n    id 'maven-publish'\n    id 'java-gradle-plugin' // 必须\n}\n\ngroup = 'com.jie'\nversion = '1.0'\n\nrepositories {\n    google()\n    jcenter()\n    mavenCentral() //必须\n}\n\n// 项目入口 插件可以使用java groovy kotlin 三种语言进行编写\nsourceSets {\n    main {\n        groovy {\n            srcDir 'src/main/groovy'\n        }\n        java {\n            srcDir 'src/main/java'\n        }\n    }\n}\n```\n\n![image-20240502101755522](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502101755522.png)\n\n## 4.3 创建入口目录，在 src/main 下创建代码入口目录\n\n![image-20240502101040546](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502101040546.png)\n\n\n\n## 4.4 实现插件代码\n\n```groovy\npackage com.jie\n\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project\n\nclass Txt implements Plugin<Project> {\n    @Override\n    void apply(Project project) {\n        project.task(\"testPlugin\") {\n            doLast {\n                println(\"Hello,Gradle Plugin\")\n            }\n        }\n    }\n}\n```\n\n## 4.5 配置插件入口\n\n```groovy\n// 插件入口\ngradlePlugin {\n    plugins {\n        DependenciesPlugin {\n            id = 'com.jie.testPlugin'\n            implementationClass = 'com.jie.Txt'\n        }\n    }\n}\n```\n\n![image-20240502102521585](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502102521585.png)\n\n## 4.6 在 module 引入我们写的插件\n\n![image-20240502102601436](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502102601436.png)\n\n然后执行插件的Task。\n\n![image-20240502102704637](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502102704637.png)\n\n这种形式的写法，在我们整个工程的 module 都可以使用，但也只是限制在本工程，其他工程不能使用。\n\n# 5、编写在单独项目中\n\n有时候我们需要一个插件在多个工程中使用，这时候我们就需要把插件上传 maven 中。\n\n## 5.1 新建Module\n\n新建一个名称为plugin的Module。\n\n![image-20240502103519070](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502103519070.png)\n\n![image-20240502103344774](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502103344774.png)\n\nGradle Plugin可以用java写，也可以用kotlin、groovy，喜欢用什么就可以在main文件下新建对应语言的文件夹接口，比如groovy文件夹。\n\n## 5.2 新建文件添加依赖\n\n### 5.2.1 添加依赖\n\n![image-20240502104334240](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502104334240.png)\n\n### 5.2.2 添加类\n\n之前是用的Groovy写，这次用 Java。\n\n![image-20240502104420578](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502104420578.png)\n\n### 5.2.3 添加插件入口\n\n```groovy\n// 插件入口\ngradlePlugin {\n    plugins {\n        DependenciesPlugin {\n            id = 'com.jie.plugin.txtPlugin'\n            implementationClass = 'com.jie.plugin.Txt'\n        }\n    }\n}\n```\n\n![image-20240502111914030](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502111914030.png)\n\n到此，Plugin的基本雏形就有了。\n\n## 5.3 发布插件\n\n### 5.3.1 添加依赖\n\n首先，比较常用的仓库是maven，在plugin>build.gradle文件中先依赖一个maven发布的插件`maven-publish`\n\n![image-20240502104703983](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502104703983.png)\n\n### 5.3.2 添加发布配置\n\n```groovy\npublishing {\n    publications {\n        myLibrary(MavenPublication) {\n            groupId = 'com.jie.plugin' //指定GAV坐标信息\n            artifactId = 'txt'\n            version = '1.0'\n\n            from components.java    //发布jar包\n        }\n    }\n\n    repositories {\n        maven {\n            url \"$rootDir/lib/release\"\n        }\n\n        //发布项目到私服中\n//    maven {\n//        name = 'myRepo' //name属性可选,表示仓库名称，url必填\n//        //发布地址:可以是本地仓库或者maven私服\n//        //url = layout.buildDirectory.dir(\"repo\")\n//        //url='http://my.org/repo' // // change URLs to point to your repos, e.g. http://my.org/repo // //认证信息:用户名和密码\n//        credentials {\n//            username = 'joe'\n//            password = 'secret'\n//        }\n//    }\n    }\n}\n```\n\n![image-20240502105217729](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502105217729.png)\n\n### 5.3.3 执行发布操作\n\n![image-20240502110731057](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502110731057.png)\n\n![image-20240502111207922](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502111207922.png)\n\n没有出现可能是idea 没有加载出来，刷新一下项目即可。\n\n![image-20240502111304684](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502111304684.png)\n\n### 5.3.4 使用\n\n在settings.gradle文件中配置插件仓库地址\n\n```groovy\npluginManagement {\n    repositories {\n        maven {\n            url \"$rootDir/lib/release\"\n        }\n    }\n}\n```\n\n![image-20240502111441643](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502111441643.png)\n\n在project>build.gradle文件中添加插件依赖\n\n```groovy\nbuildscript {\n    dependencies {\n        classpath('com.jie.plugin:txt:1.0')\n    }\n}\n```\n\n![image-20240502112020994](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502112020994.png)\n\n再建一个module进行使用。\n\n![image-20240502112406958](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502112406958.png)\n\n编译看效果：\n\n![image-20240502112520352](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502112520352.png)\n\n在控制台看到自定义插件的输出，说明自定义插件就已经生效了。\n\n最后，至于如何写一个插件，能帮助项目更加自动化或者便捷化，是值得大家未来需要长期思考、关注、努力的点。\n\n# 6、插件的关注点\n\n## 6.1 第一点:插件的引用 \n\n```groovy\napply plugin: '插件名' \n```\n\n## 6.2 第二点:主要的功能[任务]\n\n当我们在工程中引入插件后，插件会自动的为我们的工程添加一些额外的任务来完成相应的功能。以 Java 插件为例，当\n\n我们加入 java 插件之后，就加入了如下功能：\n\n![image-20240502112825658](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502112825658.png)\n\n具体大家可通过 gradle tasks 查看加入某个插件前后的区别。\n\n> 说明：Gradle 中的任务依赖关系是很重要的，它们之间的依赖关系就形成了构建的基本流程。\n\n## 6.3 第三点:工程目录结构\n\n一些插件对工程目结构有约定，所以我们一般遵循它的约定结构来创建工程，这也是 Gradle 的“约定优于配置”原则。\n\n例如 java 插件规定的项目源集目录结构如下所示：\n\n![image-20240502112922363](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502112922363.png)\n\n如果要使用某个插件就应该按照它约定的目录结构设置，这样能大大提高我们的效率，当然各目录结构也可以自己定义\n\n## 6.4 第四点：依赖管理\n\n比如前面我们提到的 依赖的类型[[依赖管理](https://blog.csdn.net/weixin_53041251/article/details/138009776?spm=1001.2014.3001.5502)]部分，不同的插件提供了不同的依赖管理。\n\n## 6.5 第五点：常用的属性\n\n例如：Java 插件会为工程添加一些常用的属性,我们可以直接在编译脚本中直接使用。\n\n| 属性名称                     | 类型        | 默认值                          | 描述                              |\n| :--------------------------- | :---------- | :------------------------------ | :-------------------------------- |\n| reportsDirName               | String      | reports                         | 生成报告的目录名称                |\n| reportsDir                   | File (只读) | buildDir/reportsDirName         | 生成报告的目录                    |\n| testResultsDirName           | String      | test-results                    | 生成测试.result.xml文件的目录名称 |\n| testResultsDir               | File (只读) | reportsDir/testReportDirName    | 生成测试报告的目录                |\n| libsDirName                  | String      | libs                            | 生成 lib 库的目录名称             |\n| libsDir                      | File (只读) | buildDir/libsDirName            | 生成 lib 库的目录                 |\n| distsDirName                 | String      | distributions                   | 生成发布文件的目录名称            |\n| distsDir                     | File (只读) | buildDir/distsDirName           | 生成发布文件目录                  |\n| docsDirName                  | String      | docs                            | 生成帮助文档的目录名称            |\n| docsDir                      | File (只读) | buildDir/docsDirName            | 生成帮助文档的目录                |\n| dependencyCacheDirNameString | String      | dependency-cache                | 存储缓存资源依赖信息的目录名称    |\n| dependencyCacheDir           | File (只读) | buildDir/dependencyCacheDirName | 存储缓存资源依赖信息的目录        |\n\n# 7 、Java 插件分析\n\n参考官网：https://docs.gradle.org/current/userguide/plugin_reference.html,以 Java 插件为例，讲解需要关注的几点：\n\n## 7.1 第一点：我们要关注插件使用\n\n```groovy\nplugins {\n\tid 'java' \n}\n```\n\n## 7.2 第二点：我们要关注插件的功能\n\n我们可通过官方文档介绍了解某个插件功能或者百度、再或者大家可以通过 gradle tasks 查看加入 java 插件前后的区别。\n\n## 7.3 第三点：项目布局\n\n一般加入一个插件之后，插件也会提供相应的目录结构，例如：java 插件的目录结构\n\n![image-20240502113555425](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502113555425.png)\n\n当然这个默认的目录结构也是可以改动的例如：\n\n```groovy\nsourceSets {\n    main {\n        java {\n            srcDirs = ['src/java']\n        }\n        resources {\n            srcDirs = ['src/resources']\n        }\n    }\n}\n```\n\n也可设置源集的属性等信息。\n\n## 7.4 第四点：依赖管理：以 **java** 插件为例，提供了很多依赖管理项\n\n![image-20240502113716311](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240502113716311.png)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1620630456775032833/SSD4egm5-gradle-logo.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 10,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1620630456775032833",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-05-02 11:50:27",
        "updateTime": "2024-05-07 18:09:30",
        "user": {
          "id": "1620630456775032833",
          "planetCode": "3790",
          "userName": "叫我阿杰好了",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1620630456775032833/VD8sEpIL-微信图片_20230523085336.jpg",
          "gender": 1,
          "userProfile": "目前技术社交账号，CSDN JAVA领域优秀创作者，阿里云专家博主。\n微信公众号：叫我阿杰好了",
          "userRole": "vip",
          "interests": [
            "资源",
            "Java",
            "GitHub",
            "面试题"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 3,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": "https://blog.csdn.net/weixin_53041251?spm=1000.2115.3001.5343",
          "score": 35,
          "coin": 20,
          "followeeNum": 2,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2025-03-12 23:57:24",
          "lastLoginTime": null,
          "createTime": "2023-02-01 11:49:45",
          "updateTime": "2024-05-02 14:50:48"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1785363333986254849",
        "title": "伙伴匹配系统第五集跨域携带cookies报错",
        "description": null,
        "content": "前端配置了myAxios.defaults.withCredentials=true;//让ajax携带cookie\n之后要是还是报错在后端的controller中加上注解：\n@CrossOrigin(origins = \"http://localhost:5173\",allowCredentials = \"true\")\n\n# 解释\n@CrossOrigin(origins = \"http://localhost:5173\",allowCredentials = \"true\")\n - 前半部分是允许该地址进行跨域  origins = \"http://localhost:5173\"\n - 后半部分是允许携带凭证        allowCredentials = \"true\"\n-  allowCredentials默认值是false",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 9,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1709383604834004993",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-05-01 01:39:23",
        "updateTime": "2024-05-07 15:14:56",
        "user": {
          "id": "1709383604834004993",
          "planetCode": "27894",
          "userName": "gnod",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/bCgeiaz0sNdY1aia6f1UxY1rAwn34KlQOccZghzVF95s4eWxTeJQdRg8Yen2J3k3DuI5UvoiaYAiaRxa7SmibfcuZuA/132",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-10-02 11:34:03",
          "lastLoginTime": null,
          "createTime": "2023-10-04 09:43:04",
          "updateTime": "2024-02-01 16:08:47"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1784548174032011265",
        "title": "挺看好的一位实习生，顶峰见！",
        "description": null,
        "content": "大家好，我是程序员鱼皮。今天我要分享自己团队里一位全栈实习生的实习总结。\n\n在实习期间，这位同学参与了多个项目的工作，包括企业动态公告系统的开发、企业周边系统的搭建、撰写技术教程、开发 IDEA 插件、构建云端管理平台等等。\n\n实习近 3 个月，我见证了他的高速成长，无论是全栈开发能力、还是软实力的提升都很大。\n\n以下是他的实习总结，给大家参考：\n\n\n\n## 鱼厂实习总结\n\n时光飞逝，转眼间在鱼厂的三个月的实习生活已经结束我也要回学校继续大三学习生活，常言天下没有不散的宴席，但分别的时候还是非常的不舍的。\n\n总体而言，实习经历我是非常满意的，并且能明显感受到自己的成长非常大。下面我来详细地总结一下我的实习生活、技术、以及软实力的成长，并且把我的经验分享给大家！\n\n\n\n### 团队氛围\n\n我们是一个年轻的团队，氛围真的非常好，没有任何所谓 “职场官腔” 这 一说，大家都十分好相处。\n\n公司有定期的团建，会去户外玩密室逃脱（上海的密室逃脱体验感真的很好，NPC 很专业）、一起运动打羽毛球、射箭，当然对于我这个桌游的重度爱好者来说，最开心的还是大家聚在一起玩桌游，后来我发现原来 **打桌游是公司文化**，周五大家工作不忙的时候都会一起玩，十分欢乐。\n\n还有，公司的饮食文化也很丰富，经常会一起聚餐，工作日老板请吃西餐是不是想想就爽；且公司有零食提供，不用担心写代码会饿着。\n\n\n\n### 编程领路人 > 老板\n\n首先很感谢鱼皮给我这次实习的机会，**其实这种感觉还挺奇妙的，自己的编程学习上的引路人变成了老板** 。平时交流上不管是工作还是生活也非常平易近人，没有因为我是一名实习生就忽略我的感受，性格也是比较和蔼的。刚开始我还没有很融入的时候会与我交流并给出建议，不会像一些领导一样当众训斥你，当然有时候员工犯了一些低级错误，比如代码不审核就上线，还是要批评的。\n\n可以给分享几点鱼皮哥给我的建议，我觉得也同时适用于大家的：\n\n1）养成开发记录的习惯，具有主人公意识\n\n2）对于工作进度及时反馈，如果有压力需要提出、抛出风险\n\n3）注重代码规范，提交规范\n\n4）大胆表达，锻炼和提高自己的沟通能力\n\n5）主动去争取机会，机会永远是自己去争取的，不要相信天上掉馅饼（我的实习机会就是主动和鱼皮沟通争取来的）\n\n以下为了保护隐私，均使用脱敏后的名字 \uD83D\uDCAD：\n\n我在鱼厂认识的第一个同事，也是第一个和我一起合租的舍友松柏（后端同学），松柏就比我大一届，但是我能非常真切的感受到业务技术能力要比我强很多很多，平时学习技术上很多不懂的问题都会问他，也得到耐心了的答复，虽然我知道很多问题都是比较基础的，这一点真的很感谢松柏哥的帮助。\n\n平时在交流上也很开心，很多时候我们都会一块回租房的地方吃晚饭、看鱼皮直播、聊聊游戏、爱好与人生。还有，我们共同的特点就是早上起不来，虽然鱼厂是 10 点上班，还是很困，我们的口号是 “今天星期四，明天星期五，后天又是周末了”。\n\n后面又认识了 LX 和 CQ ，他们是带我做项目的导师，一个负责前端一个负责后端。记得刚来公司那一会我的业务水平很差，很多技术、写文档的规范也不了解，只能一直问 CQ，我感觉 CQ 哥当时应该是对我挺无奈的，很多基础的东西也不会，没想到第一个带的实习生就这么菜，不过虽然嘴上说是基础问题，但是会给我解答并没有直接不管我了。那段时间还挺难过的，会怀疑自己、焦虑不安，**直到我收到了 CQ 五千字的工作建议与技术学习建议** ，我真的非常感动，虽然我当时技术不行，但是我想的是我必须要做出改变，于是在下班之后我开始学习那些工作中要用到但是是我的短板的技术，个人感觉还是有所进步的，下面的模块会详细介绍~\n\n![](https://pic.yupi.icu/1285/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_fa3e9139-879e-428c-a63c-717c463a4cea.png)\n\n虽然我的工作是全栈实习生，但是我的前端其实只能算是写过，并没有系统学习过。因此在写项目的过程中，特别是前端这一块会磕磕碰碰，我的前端导师 LX 会给我技术上的指导，会告诉我用什么技术可以实现让我自己去摸索，后来我意识到 “只有自己学会去解决问题才是成长”。LX 给我的建议就是先打好基础，弄懂 JS 的基础语法，再去学框架会很快，我觉得这是十分科学的，也建议想学前端的同学按照这个顺序来学。\n\n不过我想，回忆起来最快乐的是午休时间打洛克王国吧，我们俩用 6、7 年前的宠物被现在的神宠吊打 \uD83D\uDE2D，我想要是用钻研技能的热情来学技术获取能更厉害一些 \uD83D\uDE02。\n\n我们中午同事基本都会一起出去吃午饭，小 y 的那一句 “拉面、广场、米粉王” 已经深深刻在我的脑海里，我寻思着果然有当产品经理的天赋啊，把问题都抛给程序员了\uD83D\uDE1D。小y 是公司的运营，也是编程导航的运营，平时虽然交流的不多（因为和开发同学交流多一些），但是还是非常能感受到他的热情，特别是每次玩桌游的时候都会跟我说 “自己人，别搞”，虽然他跟谁都说是自己人。\n\n之后，我又认识了我们公司另一位前端大佬阿星也是元老级员工，他教会了我很多 React 中开发的技巧以及 Ant Design Pro 框架的使用，并且给我推荐了一份学习资源：《React Hooks 核心原理与实战》，讲的真的非常好，新手也能看懂，高手更能理解其中精髓。\n\n不过我认为阿星更适合教学，比如他会教会我在前端如何去定位问题，用什么技术去解决问题、如何阅读官方文档等会给我举例子讲解，很期待之后能看到他直播讲解前端的知识，当然印象很深的是他请我们喝的柠檬茶，至于什么原因可以去看看鱼皮的公众号了解 —— [员工写了个大 BUG，网站痛失 300 元！](https://mp.weixin.qq.com/s/jemiaYwhzaAoB1PO2j8Z7A)。\n\n\n\n### 技术成长\n\n我目前大三在读，平时学技术的时候是偏 Java 后端，也会一点前端，入职的时候鱼皮哥给我安排的是全栈实习生的工作，我个人认为我在整个实习期做的事还是很多的，对我技术成长帮助很大。整个实习培养的过程是循序渐进并且能学到真材实料的，并不是像网上传言找一个实习生来打杂。会有清晰的需求，要做什么并且有意义的去做。\n\n以下我分几个阶段去讲：\n\n\n\n#### 1、线上实习\n\n刚开始线上的时候给我安排的主要是熟悉公司的工作，包括开发规范、公司内部后端代码、阅读公司的已有技术业务的沉淀以及同事的日常工作记录，这里因为隐私原因没法给大家透露细节可以参考星球内部分享过的 **企业级开发流程** 以及 **阿里巴巴开发手册**，但是能给到大家的建议就是，刚开始工作的时候 **一定一定要仔细研读公司的开发规范和提交规范** 。如果规范上写明的要求，你在写代码的时候还是没有注意是一定会被同事批评的，想想你的同事写了一堆屎山代码让你来维护你气不气。\n\n其次就是，强烈建议大家阅读 [编程导航](https://mp.weixin.qq.com/s/AjD2dKA5br0htPo1iqzkBQ) 的后端模板代码，这一点是我刚进公司松柏就给我的建议，多读高手写的代码多去调试并且做到真正的理解内化，理解每一个函数、每一个类的作用是什么，以及为什么要这么设计，一些技术实现的原理是什么，**我敢说如果大家能把编程导航后端模板那一套东西吃透，至少在实习阶段你肯定是能干活的，并且80% 的业务也是能够上手的** ，那有同学可能会问还有 20% 呢？不用担心这个阶段暂时也不需要你来做。\n\n再之后给我安排了一些调研的工作，并产出调研文档，了解到了 AI 搜索引擎的产品。这一块给我 **最大的感受就是工作与在校学习的差别 ，在校的时候可能老师会给你找到资料、实现方法等，甚至把代码都给你改改就能使用，但是在公司我们需要做产品调研、技术调研、方案可行性的思考等。建议大家自己在做项目的时候也要养成调研的习惯并思考：这个需求到底有没有做的意义。\n\n技术方面，主要是在学习 Java 的网络爬虫知识，在编程导航聚合搜索项目的第二期里有讲到，我还开发了一个自动化填写问卷的小脚本。\n\n\n\n#### 2、线下实习\n\n之后来线下，公司有配备工作 Mac 电脑（Mac 写代码是真得舒服除了不能打游戏 hhh），熟悉了几天，鱼皮哥就给了一个独立负责项目的机会，让我单独完成动态公告系统。\n\n简单介绍一下这个项目，在面对网站故障、需要通知用户或进行临时公告时，为了提供一种简便而灵活的方式，我们希望设计一个通用的公告系统。该系统允许管理员在系统后台轻松创建通知，并灵活配置通知的内容、展示时间、网站生效范围等参数。\n\n这个项目复杂度并不高，但是对于第一次实习的我来说，还是一个比较具有挑战性的任务，因为在此之前只是跟着教程写代码，并没有发挥出自己的自主性，因此刚开始做的比较慢，效果也并不好，不过好在我的导师给了我很大的帮助，告诉我需求文档与设计文档要怎么写，如何做需求排期、风险管理等。鱼皮哥也没有给我很大的时间上的压力，放手让我去做。通过一次次的迭代终于可以达到验收的水准了，说实话我当时成就感还是比较大的，这是我 **第一次负责独立项目，并且从 0 - 1 完成。** 完成后我又写了详细的项目总结文档，复盘我遇到的问题，给大家分享一下我学到的知识点：\n\n1）IDEA 多环境的配置，区分线下和线上配置\n\n2）团队开发流程与规范 ：每一步都必须要写好文档，包括需求分析文档、调研文档、技术选型文档（技术调研）、详细设计文档，**一定要理清核心业务，再进行开发** 。\n\n3）代码复用能力，复用公司的前后端模板，快速进行二次开发\n\n4）Mac 快捷键的学习，形成自己的工作流 （这个是松柏教我的，省下的时间可以适当摸鱼 \uD83D\uDC1F）\n\n5）MyBatis-plus 分页插件使用（前后端的对接）\n\n6）如何解决前端传入的数据与后端需要接收的数据不匹配的问题（JSON处理）\n\n7）阅读官方文档的能力：解决修改列表渲染样式、表单字段渲染样式、是否展示属性配置等，还要熟悉 Ant Design 的常用组件。\n\n8）学会开发一个优秀的前端 SDK（JS 脚本）。包括定位打包后 JS 文件过大的原因、使用原生 JS 开发弹窗代替依赖库来写一个弹窗样式、用 Fetch 代替 Axios 写请求接口等。这些操作可以大大减小压缩文件的体积，方便用户引入，减少消耗的资源。\n\n9）腾讯云对象存储的安全使用\n\n\n\n#### 3、负责独立项目\n\n鱼皮之后又给我安排了一个独立的项目 —— 企业级周边系统，这次的项目难度以及工作体量相较于动态公告系统是要上一个等级的，所以我说鱼厂的培养制度是循序渐进的并非无道理。\n\n还是简单介绍一下这个项目背景，在我们过去的周边信息管理中，存在着对内（公司内部周边管理）和对外（向用户展示周边信息）两个独立的表单。这种模式导致了大量信息的重复填写，同时也增加了人工维护的成本和压力。为了解决这一问题，我们迎来了周边系统的诞生。这一次相比我第一次开发， 我觉得最明显的进步在于更熟悉开发流程与规范了，比如我会自主进行需求的排期，文档的沉淀，并且一些重复性的 CRUD 代码也更加熟练了，不需要花很多时间就能完成，可以把时间重点放在思考核心业务的设计上，并且将想法和同事反馈，可以帮助我辅助思路以及设计的可行性。\n\n> 地址：http://prize.yuyuanweb.com/\n\n![](https://pic.yupi.icu/1/image-20240409151145088.png)\n\n值得一提的，**我的导师会认真看我写的设计文档，并给出详细的改进建议**，在此之前我一直认为设计数据库是比较复杂的，现在虽然不能说得心应手，也积累了一些自己的经验，能对付一些常见的系统设计了。\n\n如果说前一个项目我更的是在学习开发的知识的话，这一个项目可以帮助我巩固熟悉开发流程，之后可以很快地开发一个类似的系统，并且真实的感受到企业中一步一步优化项目的过程。并且最后鱼皮给了我一台单独的服务器，学会了部署上线的方法。第一次部署的时候还不太熟，好在 CQ 给我讲了 Nginx 的反向代理的，并且我也沉淀了详细的部署文档，之后再部署的时候可以控制在小时级别内了。之后说不定各位鱼友就能用上我们的周边系统挑选周边了~\n\n\n\n#### 4、撰写技术文档\n\n年后，鱼皮给我安排了撰写项目教程的任务，让我完成我负责的两个项目详细教程的编写，手把手教我如何写教程文章，写好文章大纲、保证语言的通俗易懂，如果是规范的教程，可以参考鱼皮哥在星球分享的 [代码生成器共享平台](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247557397&idx=1&sn=2bfd82f22ddb118c0f77f34e7cb05593&scene=21#wechat_redirect) 教程，可以说我没有见过比这更细文字版的教程了。\n\n写第一个项目的教程的时候还不是很熟悉，有一些写作格式与规范还不太了解，以及部分内容过于机械化，鱼皮哥会详细看我的教程，并给出优化的建议，应该怎么引导读者、怎么拆分内容、如何写地更加专业规范等，让我在写第二个项目教程的时候更加熟练且得心应手了。\n\n![](https://pic.yupi.icu/1285/image-20240409103914096.png)\n\n总的来说，这个阶段我可以很明显感觉到自己写作能力的进步，有了框架后，写作思路更加清晰了。\n\n\n\n#### 5、开发 IDEA 插件\n\n再之后，我们公司研发上线了代码小抄：一个易用的代码分享工具，支持快速跨设备分享代码、阅读他人代码、在线运行代码、AI 分析和代码纠错等功能。\n\n> 代码小抄：https://www.codecopy.cn/\n\n而我也接到了一个新的需求，开发代码小抄的 IDEA 插件，其实当时鱼皮在 B 站上发布了视频介绍代码小抄，下面评论区有一个 “产品经理” 提出了开发一个插件的需求，我就知道事情并不简单！鱼皮一定是看到了他的评论决定给我这个需求的 \uD83D\uDE2D。\n\n> 鱼皮：其实并不是，很早之前就计划好了！\uD83D\uDC36\n\n这对于我来说，也是一个不小的挑战，因为我之前在网上调研过 IDEA 插件的开发教程，可以说是少的可怜，要么就是非常入门没有深度，要么就是过时的教程不适合新版本 IDEA，所以光是调研教程，学习 IDEA 插件开发，跑通 Demo，我就花了两三天的时间，因为项目用的是 Gradle 依赖管理工具，我对这个东西不是很熟，刚开始一直拉取依赖失败，配了很久的环境，一直跑不起来，好在之后配置了本地的 Gradle，开了代理之后终于能安装上依赖了。\n\n按照惯例，还是介绍这个项目：这款插件是专为代码小抄项目设计的，开发同学可以直接在 IntelliJ IDEA 开发工具中一键分享代码到代码小抄，并快速获取分享链接，然后就可以把代码转发给更多人啦~\n\n在开发过程中还是学到了很多知识的，比如插件的开发步骤、重要的模块、扫码登录的开发、如何在 IDEA 插件中种上 Cookie 等。\n\n\n\n#### 6、开发云端管理平台\n\n再之后，我们公司自研的超级剪切板工具 - 剪切助手也进入内测了，这是一个界面精美、简单易用、支持快速复制多条内容并自由粘贴的效率工具。\n\n> 官网：https://jianqiezhushou.com/\n\n![](https://pic.yupi.icu/1/1712632997742-76c75db3-5636-4709-88fd-47f0fb688034.png)\n\n\n\n我虽然没有直接参与项目业务的开发，但是也做了一些贡献，开发了剪切助手云端管理平台，支持用户云端管理自己的剪切内容。\n\n在这个项目中，我学到了很多前端开发的技术，比如怎么实现一个带格式化的复制功能（我们使用 Render 函数后，渲染出来的内容无法直接使用表格组件自带的 Copyable 复制）、集成富文本编辑器（更好地展示用户复制帖子的内容）、在前端实现微信二维码登录等。同时也学到了一些 CSS 技巧，比如当我们需要修改两个地方用到一个组件的样式应该怎么做。\n\n阿星教我了一个开发技巧，给每一个页面都要写一个 CSS Class 类名，找到包裹这两块不同的类名给他复制下来，然后通过唯一的类名进行修改对应其下的元素样式即可。\n\n\n\n---\n\n\n\n以上呢，就是我近三个月的实习工作。我个人认为这种方式是很能锻炼一个实习生的，能很明显感受自己的技术成长。\n\n也分享一下我之前的简历。\n\n全栈实习生简历：https://www.laoyujianli.com/share/yupi3\n\n\n\n## 软实力成长\n\n1）养成独立解决问题的习惯\n\n我觉得这一点是对我帮助最大的，作为新人，**遇到问题时首先去尝试思考，独立解决**，是非常重要的。\n\n\n\n2）学会提问的智慧\n\n这也是鱼皮哥在星球置顶帖中提到的，我们在问别人问题的时候需要尽量描述清楚自己的问题，自己尝试的方案，失败的原因等，才能让别人更好的帮助你解答问题。\n\n\n\n3）提升自己的表达能力\n\n这一点是承接上文的，不管是与人交流，还是写文章，都需要展现出自己的表达能力。其实我的表达能力并不好，中学的时候作文也只是及格水平，没有那么出彩。需要通过多说，多写来锻炼自己。\n\n\n\n4）提高自己的总结复盘能力\n\n这一点我觉得我已经养成了习惯，至少现在在做完一个项目，或者看完一门教程，我都会产出一篇文档来专门做总结，做完一件事也会复盘自己做的好的或者不好的地方，方便自己下一次改进，做得更好。还有就是公司会写周报，把自己日常做的事记录下来，开会的时候一起讨论进度，也能锻炼自己这方面的能力。\n\n\n\n5）和同事一起吃饭\n\n融洽的同事关系，能够让工作起来更加舒服和高效，在吃饭的时候，通过和同事的交流，也能获得一些自己平时无法得到的信息，提高自己的认知。特别是在和一些比你更厉害的牛人交流的时候，你能收获到的会更多。\n\n\n\n6）及时记录灵感\n\n每个阶段的学习方法是会改变的，随着知识的积累。比如一开始学习写代码只是模仿，到后面就可以自己根据设计参考文档写出代码。**对于一些知识点，需要自己能讲出来才算是真正的理解。**\n\n\n\n## 业务提升\n\n聊聊我来上海的生活吧，我是一个美食爱好者，梦想是吃遍全中国所有爱吃的食物，且我也喜欢旅行，来上海去游玩了一些比较出名的网红打卡点，像外滩、东方明珠塔、武康大楼、豫园等景点还是非常值得一去的。平时的爱好就是在公寓里和朋友一块玩金铲铲，并自创了一个金铲铲滴牌理论（当单局内刷新次数大于 80 次的时候常客优惠会比棱彩门票更有价值），在大家都有空的时候会一块聚在公司打桌游。\n\n项目方面，补了之前搁置的鱼皮 API 开放平台项目，了解到分布式 RPC 框架的使用，以及微服务网关 Spring Cloud Gateway 的知识。我还把智能 BI 项目拉下来回顾，重新复习了一遍消息队列的知识，因为我个人很喜欢这个 AIGC 项目，并且感觉可以做的事情非常多，打算对这个项目进行持续的扩展，后面也会不定期更新项目拓展笔记，感兴趣的同学可以看一看我的源码：http://gitlab.code-nav.cn/szdaiyifei/bi 。\n\n目前正在读的是鱼皮的手写 RPC 框架教程，已经完成了前六章的代码编写，不过还是有一些难度的，毕竟 RPC 用的还不够熟练，就要自己写一个轮子。像自定义的 SPI 机制还是比较复杂的，只能多读几遍来帮助自己更好地理解。\n\n![](https://pic.yupi.icu/1285/image-20240409104539107.png)\n\n\n\n技术方面，我打算认真系统学习设计模式，学习到前人总结出来的开发规范，目标是能写出更优雅可复用的代码。计划先把《大话设计模式》通读一遍，再去尝试手写简单的设计模式，最后把它们应用到项目里。比如 [编程导航](https://mp.weixin.qq.com/s/AjD2dKA5br0htPo1iqzkBQ) 的聚合搜索和 OJ 都用到了大量设计模式，之后可以在项目中实践。还有数据结构与算法的学习，我要日拱一卒，计划阅读《数据结构之美》这份专栏，听说写的十分不错，搭配着刷 Leecode 热门题集。\n\n阅读方面，最近比较喜欢读一些哲学类的书籍，以及一些提升自己软实力的书，像耗子叔的左耳听风专栏绝对是经典中的经典。我会利用碎片化的时间，比如等车、通勤、下班回租房的路上等时间来看编程导航内大家分享的文章，并且在能力范围内帮助大家解答问题。\n\n\n\n## 未来展望\n\n虽然我的实习生活结束了，但生活还在继续。计划是回学校认真准备考研了，因为自己的第一学历是双非本科，在学历这方面是没有什么竞争力的，我觉得机会摆在我面前，我要去珍惜，去努力尝试一下，享受这个过程，并且我觉得我的 408 基础学科学的不是很扎实，借此机会巩固一下自己的专业基础能力。\n\n当然更久远的计划还是能继续提高我的技术水平，多做一些项目，并且在博客网站分享一些自己的技术文章，目标是能在互联网这一块找到自己的一席之地吧！\n\n最后，真的非常感谢阅读，祝好！❤️\n\n![](https://pic.yupi.icu/1285/FnwBM9gKsh_V5iz5ZeWVimc0CmY5.png)\n\n\n\n---\n\n\n\n以上，就是我们实习生同学的分享啦，希望对大家有帮助。\n\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 72,
        "thumbNum": 8,
        "favourNum": 2,
        "commentNum": 2,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-04-28 19:40:14",
        "updateTime": "2024-05-07 21:20:45",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3095,
          "coin": 170,
          "followeeNum": 1510,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2287-05-20 01:46:39",
          "lastLoginTime": null,
          "createTime": "2022-12-09 12:32:33",
          "updateTime": "2024-05-08 10:43:13"
        },
        "tags": [
          "文章",
          "实习"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "4250",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "532"
  },
  "message": "ok"
}